$date
	Mon May  1 12:56:40 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module Mux8Way16_tb $end
$var wire 16 ! out [15:0] $end
$var reg 16 " a [15:0] $end
$var reg 16 # b [15:0] $end
$var reg 16 $ c [15:0] $end
$var reg 16 % d [15:0] $end
$var reg 16 & e [15:0] $end
$var reg 16 ' f [15:0] $end
$var reg 16 ( g [15:0] $end
$var reg 16 ) h [15:0] $end
$var reg 3 * sel [2:0] $end
$scope module u_Mux8Way16 $end
$var wire 16 + a_i [15:0] $end
$var wire 16 , b_i [15:0] $end
$var wire 16 - c_i [15:0] $end
$var wire 16 . d_i [15:0] $end
$var wire 16 / e_i [15:0] $end
$var wire 16 0 f_i [15:0] $end
$var wire 16 1 g_i [15:0] $end
$var wire 16 2 h_i [15:0] $end
$var wire 3 3 sel_i [2:0] $end
$var wire 16 4 tmp2 [15:0] $end
$var wire 16 5 tmp1 [15:0] $end
$var wire 16 6 out_o [15:0] $end
$scope module u1_Mux4Way16 $end
$var wire 16 7 a_i [15:0] $end
$var wire 16 8 b_i [15:0] $end
$var wire 16 9 c_i [15:0] $end
$var wire 16 : d_i [15:0] $end
$var wire 2 ; sel_i [1:0] $end
$var wire 16 < out_o [15:0] $end
$upscope $end
$scope module u2_Mux4Way16 $end
$var wire 16 = a_i [15:0] $end
$var wire 16 > b_i [15:0] $end
$var wire 16 ? c_i [15:0] $end
$var wire 16 @ d_i [15:0] $end
$var wire 2 A sel_i [1:0] $end
$var wire 16 B out_o [15:0] $end
$upscope $end
$scope module u_Mux16 $end
$var wire 16 C a_i [15:0] $end
$var wire 16 D b_i [15:0] $end
$var wire 1 E sel_i $end
$var wire 16 F out_o [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 F
0E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
b0 0
b0 /
b0 .
b0 -
b0 ,
b0 +
b0 *
b0 )
b0 (
b0 '
b0 &
b0 %
b0 $
b0 #
b0 "
b0 !
$end
#20000
b1 ;
b1 A
b1 *
b1 3
#30000
b10 ;
b10 A
b10 *
b10 3
#40000
b11 ;
b11 A
b11 *
b11 3
#50000
b0 ;
b0 A
1E
b100 *
b100 3
#60000
b1 ;
b1 A
b101 *
b101 3
#70000
b10 ;
b10 A
b110 *
b110 3
#80000
b11 ;
b11 A
b111 *
b111 3
#90000
b1001000110100 !
b1001000110100 6
b1001000110100 F
b101011001111000 4
b101011001111000 B
b101011001111000 D
b1001000110100 5
b1001000110100 <
b1001000110100 C
b0 ;
b0 A
0E
b0 *
b0 3
b1000100110101011 )
b1000100110101011 2
b1000100110101011 @
b111100010011010 (
b111100010011010 1
b111100010011010 ?
b110011110001001 '
b110011110001001 0
b110011110001001 >
b101011001111000 &
b101011001111000 /
b101011001111000 =
b100010101100111 %
b100010101100111 .
b100010101100111 :
b11010001010110 $
b11010001010110 -
b11010001010110 9
b10001101000101 #
b10001101000101 ,
b10001101000101 8
b1001000110100 "
b1001000110100 +
b1001000110100 7
#100000
b10001101000101 !
b10001101000101 6
b10001101000101 F
b10001101000101 5
b10001101000101 <
b10001101000101 C
b110011110001001 4
b110011110001001 B
b110011110001001 D
b1 ;
b1 A
b1 *
b1 3
#110000
b11010001010110 !
b11010001010110 6
b11010001010110 F
b11010001010110 5
b11010001010110 <
b11010001010110 C
b111100010011010 4
b111100010011010 B
b111100010011010 D
b10 ;
b10 A
b10 *
b10 3
#120000
b100010101100111 !
b100010101100111 6
b100010101100111 F
b100010101100111 5
b100010101100111 <
b100010101100111 C
b1000100110101011 4
b1000100110101011 B
b1000100110101011 D
b11 ;
b11 A
b11 *
b11 3
#130000
b1001000110100 5
b1001000110100 <
b1001000110100 C
b101011001111000 4
b101011001111000 B
b101011001111000 D
b101011001111000 !
b101011001111000 6
b101011001111000 F
b0 ;
b0 A
1E
b100 *
b100 3
#140000
b110011110001001 !
b110011110001001 6
b110011110001001 F
b10001101000101 5
b10001101000101 <
b10001101000101 C
b110011110001001 4
b110011110001001 B
b110011110001001 D
b1 ;
b1 A
b101 *
b101 3
#150000
b111100010011010 !
b111100010011010 6
b111100010011010 F
b11010001010110 5
b11010001010110 <
b11010001010110 C
b111100010011010 4
b111100010011010 B
b111100010011010 D
b10 ;
b10 A
b110 *
b110 3
#160000
b1000100110101011 !
b1000100110101011 6
b1000100110101011 F
b100010101100111 5
b100010101100111 <
b100010101100111 C
b1000100110101011 4
b1000100110101011 B
b1000100110101011 D
b11 ;
b11 A
b111 *
b111 3
#1160000
